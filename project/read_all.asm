IF1
	INCLUDE C:\TASM\proj\MACROS.MAC
ENDIF

DATA SEGMENT PARA PUBLIC 'DATA'
	EXTRN LEN_SIR_A			:BYTE
	EXTRN LEN_SIR_B			:BYTE
	EXTRN SIR_A				:BYTE
	EXTRN SIR_B				:BYTE
	
	SIR_A_INPUT_MESSAGE_1	DB 10,13,"Please input the string.",10,13,"It can have at most $"
	SIR_A_INPUT_MESSAGE_2 	DB " characters.",10,13,"Press Enter to submit string.",10,13,"$"
	FULL_SIR_MESSAGE 		DB 10,13,"You have reached maximum nr. of characters. Discarding further input...",10,13,"$"
	
	SELECT_OPTION_MESSAGE 	DB "Please select if the program must be case sensitive or case insensitive.",10,13,"Press 1 for case sensitive, press 2 for case insensitive. ",'$'
							 
	INVALID_INPUT_MESSAGE 	DB 10,13,"The entered value is not valid. Please enter a valid value.",10,13,'$'
	
	FILE_NAME 				DB "C:\TASM\data.txt",0
DATA ENDS

CODE SEGMENT PARA PUBLIC 'CODE'
ASSUME CS:CODE, DS:DATA

EXTRN DISPLAY_AX:NEAR

PUBLIC READ_ALL

	READ_ALL PROC NEAR
		PUSHALL
		
		DISPLAY_MESSAGE SELECT_OPTION_MESSAGE
		
		
		NXT:MOV AH,01H
			INT 21H			;READ NEW CHAR
			
			CMP AL,'1'		;SELECTED CASE SENSITIVE
			JE GATA
			
			CMP AL,'2'		;SELECTED CASE INSENSITVE
			JE GATA
							
							;IF REACHED HERE, INPUT IS NOT VALID
			DISPLAY_MESSAGE INVALID_INPUT_MESSAGE   
			JMP NXT			;NEED VALID INPUT
		
		GATA:
		CALL READ_FROM_USER	;READ SIR_A
		CALL READ_FROM_FILE	;READ SIR_B
		
		CMP AL,'1'
		JE READ_ALL_GATA   	;THE PROGRAM IS CASE SENSITIVE
		
							;THE PROGRAM IS CASE INSENSITIVE, SO TRANSFORM
							;BOTH SIR_A AND SIR_B TO UPPER_CASE
		LEA BX,SIR_A
		INC BX				;SIR_A IS 1-INDEXED
		XOR CH,CH
		MOV CL,LEN_SIR_A
		CALL TO_UPPER_CASE  ;SIR_A IS TRANSFORMED TO UPPER_CASE
		
		LEA BX,SIR_B
		INC BX				;SIR_B IS 1-INDEXED
		XOR CH,CH
		MOV CL,LEN_SIR_B
		CALL TO_UPPER_CASE  ;SIR_B IS TRANSFORMED TO UPPER_CASE

		READ_ALL_GATA:
		POPALL
		RET
	READ_ALL ENDP	
	
	;DS:BX-THE STRING, CX-THE LENGTH OF THE STRING
	TO_UPPER_CASE PROC NEAR
		PUSHALL
		
		XOR SI,SI;CURRENT POSITION
		
		REPET:	JCXZ TO_UPPER_END			;THE STRING IS ENPTY
				CMP BYTE PTR [BX+SI],'a'
				JB NO_LOWER_CHAR			;CURRENT CHARACTER IS BELOW 'a'
				
				CMP BYTE PTR [BX+SI],'z'
				JA NO_LOWER_CHAR			;CURRENT CHARACTER IS ABOVE 'z'
				
				SUB BYTE PTR [BX+SI],'a'-'A';TRANSFORM LOWER_CASE IN UPPER_CASE
				
				NO_LOWER_CHAR:
				INC SI
				LOOP REPET
		
		TO_UPPER_END:
		POPALL
		RET
	TO_UPPER_CASE ENDP
	
	;READS SIR_B FROM FILE_NAME FILE
	READ_FROM_FILE PROC NEAR
		PUSHALL
		
		MOV AH,3DH
		LEA DX,FILE_NAME
		MOV AL,0        ;FILE OPEN MODE
		INT 21H			;OPEN FILE. AX = FILE HANDLE
		
		MOV BX,AX
		MOV CX,MAX_LEN  ;NR. OF BYTES TO READ
		
		LEA DX,SIR_B	
		INC DX			;WE READ SIR_B FROM POSITION 1
		MOV AH,3FH
		INT 21H			;READ FROM FILE
		
		MOV LEN_SIR_B,AL;STORE THE NR OF READ CHARACTERS
		
		MOV AH,3EH
		INT 21H			;CLOSE THE FILE
		
		POPALL
		RET
	READ_FROM_FILE ENDP
	
	
	READ_FROM_USER PROC NEAR
		PUSHALL
		
		DISPLAY_MESSAGE SIR_A_INPUT_MESSAGE_1	;DISPLAYS FIRST PART OF THE MESSAGE
		MOV AX,MAX_LEN
		CALL DISPLAY_AX							;DISPLAYS MAXIMAL NUMBER OF CHARACTERS
		DISPLAY_MESSAGE SIR_A_INPUT_MESSAGE_2	;DISPLAYS SECOND PART OF THE MESSAGE
		
		XOR SI,SI					;SI STORES POSITION OF SIR_A
									;IN WHICH WE READ CHARACTER
		
		AGAIN:
				MOV AH,01H
				INT 21H				;READ NEW CHARACTER
				
				CMP AL,13  			;FIND IF ENTER WAS ENTERED
				JE FINISH
								
				INC SI  			;INCREASE CURRENT POSITION
				MOV SIR_A[SI],AL	;STORE THE CHARACTER IN SIR_A
				
				CMP SI,MAX_LEN		
				JE DISCARD_INPUT	;THE STRING IS FULL

				JMP AGAIN
		
		DISCARD_INPUT: DISPLAY_MESSAGE FULL_SIR_MESSAGE
		
		FINISH:
		MOV AX,SI
		MOV LEN_SIR_A,AL			;STORE LEN_SIR_A
		POPALL
		RET
	READ_FROM_USER ENDP
	

CODE ENDS
END READ_ALL